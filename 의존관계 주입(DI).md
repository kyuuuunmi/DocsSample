## 제어의 역전(IoC)과 의존관계 주입 
스프링의 IoC컨테이너는 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화 한 것이다.
그런데 IoC컨테이너 라는 말로는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다. 
그래서 의존관계 주입(Dependency Injection)이라는 이름을 사용한다. 

`Spring IoC 기능의 대표적인 동작원리 => DI(Dependency Injection)`


## 런타임 의존관계 설정 
###의존관계 
**의존한다 ?** 
의존한다는 것은 의존대상이 변하면 기대고 있는 대상 또한 영향을 미친다는 것이다. 그리고 반드시 의존관계에는 방향성이 있다.

### UserDao의 의존관계
`UserDao`는 `DConnectionMaker`가 아닌 `ConnectionMaker`인터페이스에만 의존하고 있다. 
인터페이스에 대해서만 의존관계를 만들어 두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다. 즉, 결합도가 낮다.

그런데 클래스나 인터페이스를 통해 드러나는 의존관계 말고 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있는데, 이를 런타임 의존관계 또는 오브젝트 의존관계라고 한다. 
이는 설계시점의 의존관계가 실체화된 것이라고 볼 수 있는데, 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다. 
프로그램이 시작되고 `UserDao` 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 **의존 오브젝트(dependent object)**라고 말한다.

그리고 **의존관계 주입**은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체 보통 클라이언트라고 부르는 오브젝트를 **런타임** 시에 연결해 주는 작업을 말한다. 

DI는 다음과 같은 세 가지 조건을 충족하는 작업을 말한다. 

- 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다. 
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다. 

핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3 의 존재가 있다는 것이다.
 제3 의 존재는 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 Application Context, Bean Factory, IoC Container 등을 말한다.
 


 ## UserDao의 의존관계 주입
 
 ``` java
 public UserDao(){
    ConnectionMaker = new DConnectionMaker();
 }
 ```
 

 관계설정의 책임을 분리하기 전의 UserDao클래스의 생성자이다. `UserDao`는 이미 설계 시점에서 `DConnectionMaker`라는 구체적인 클래스의 존재를 알고 있다. 이는 이미 런타임 시의 의존관계가 코드 속에 다 미리 결정되어 있다는 점이다. 그래서 IoC방식을 써서 `UserDao`로부터 런타임 의존관계를 드러내는 코드를 제거하고 제 3의 존재에 런타임 의존관계 결정 권한을 위임한다. 
 
 여기서는 제3 의 역할을 `DaoFactory`가 담당한다. 의존관계 주입 작업을 주도하는 존재이며, 동시에 IoC 방식으로 오브젝트의 생성과 초기화 제공 등의 작업을 수행하는 컨테이너다.
 그래서 의존관계 주입을 담당하는 컨테이너라고 볼 수 있고 DI컨테이너, IoC/DI컨테이너라는 식으로 사용하기도 한다. 
 
 **주입**이라는 것은외부에서 내부로 무엇인가를 넘겨줘야 하는데 자바에서는 오브젝트의 레퍼런스를 전달 해 주는 것이다. 가장 쉽게 사용할 수 있는 파라미터 전달이 가능한 메소드는 바로 생성자이다. 
 
 DI컨테이너는 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이 생성자의 파라미터로 오브젝트 레퍼런스를 전달해준다. 

 ```java
 public class UserDao{
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;
    }
 }

```
  
  DI 컨테이너에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 메소드를 통해 DI 컨테이너가 오브젝트 주입해주는 것과 같다고 해서 이를 의존관계 주입이라고 부른다.
   
   
  또한 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC개념에 잘 들어맞는다. 
  
  
  ### 의존관계 검색과 주입 
  
 스프링이 제공하는 IoC방법에는 의존관계 주입만 있는 것이 아니라, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계 검색이라고 불리는 것도 있다. 
 
 `DaoFactory`는 런타임 시점에 `UserDao`가 사용할 `ConnectionMaker`타입의 오브젝트를 결정하고 이를 생성한 후에 `UserDao`의 생성자 파라미터로 주입해서 `UserDao`가 `DConnectrionMaker`의 오브젝트와 런타임 의존관계를 맺게 해준다. 이는 DI를 적용한 셈이다.
  
 의존관계 검색은 외부로부터의 주입이 아니라 스스로 `DaoFactory`에 요청하는 것이다. 이런 작업을 일반화 한 스프링의 Application Context라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾는 의존관계 검색을 하게 된다. 
 
 ```java
public UserDao(){
    AnnotationConfigApplicationContext context = 
        new AnnotationConfigApplicationContext(DaoFactory.class);
    this.connextionMaker = context.getBean("connectionMaker", ConnectionMkaer.class);
}
```

**의존관계 검색 vs 의존관계 주입**  

 코드를 보면 후자가 훨씬 깔끔하다. 전자는 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 성격이 다른 오브젝트에 의존하게 되는 것이므로 그다지 바람직하지 않다. 그래서 대게는 의존관계 주입방식을 사용하는 편이 낫다.
그렇지만  DI를 이용해 오브젝트를 주입받을 방법이 없을 경우(main())나 서버에서 사용자의 요청을 받을 때 같이 의존관계 검색 방식을 사용해야 할 때가 있다.  
가장 중요한 차이점은 검색 방식에서는 오브젝트는 자신이 스프링의 빈일 필요가 없다는 점이다. 반면 주입에서는 DI가 적용되려면 반드시 빈 오브젝트여야 한다. 
  
  
  
  
  ## 의존관계 주입의 응용 
  
  DI 기술의 장점은 다른 책임을 가진 사용 의존 관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며,
  변경을 통한 다양한 확장 방법에는 자유롭다. 
  
  
  ### 기능 구현의 교환 
  부하가 큰 DB의 경우, 개발 도중에는 개발자 로컬 DB를 사용해야 한다. 
  배치에 들어갈 때, DB관련 모듈을 교환해야 할 텐데 DI 방식을 적용해서 Connection을 만들었다면 한 줄의 수정만으로도 DB를 교체할 수 있을 것이다.
  
  즉 개발환경과 운영환경에서의 DI의 설정정보에 해당하는 컨테이너만 다르게 만들어 두면 나머지 코드에는 전혀 손대지 않고 개발 시와 운영 시에 각각 다른 런타임 오브젝트에 의존관계를 갖게 해줘서 문제를 해결 할 수 있다.
   
  
  ### 부가기능 추가 
  
  추가적인 부가 기능을 추가 할 때도, DI 컨테이너에서라면 간단히 구현 할 수 있다. 
  오브젝트 사이에 오브젝트를 하나 더 추가하여 의존관계를 추가해 런타임 의존관계만 새롭게 정의해주면 기존의 코드 수정하지 않고 구현 가능하다. 
  즉, 의존관계를 재정의 하는 것만으로 부가적인 기능을 쉽게 구현할 수 있다. 
  
  
  ## 메소드를 이용한 의존관계 주입
  
  지금까지는 의존관계 주입을 위해 생성자를 사용했다. 생성자보다 더 자주 사용되는 방법들이 있다.
  
  1. **수정자 메소드를 이용한 주입**  
  수정자 메소드(setter)의 핵심 기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것이다. 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적당하다.
   
  2. **일반 메소드를 이용한 주입**  
   한 번에 여러 개의 파라미터를 받을 수 있는 일반 메소드를 DI용으로 사용 할 수 있다. 
  
  전통적으로 1번, 수정자 메소드를 가장 많이 사용해왔고, 가장 사용하기 편리하다. 
  하지만 스프링은 그외에도 다양한 주입 방법을 지원한다. 
  
  
  
  
  
  