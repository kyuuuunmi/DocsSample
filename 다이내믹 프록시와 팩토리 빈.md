
## 프록시와 프록시 패턴, 데코레이터 패턴 

단순히 한 가지 기능을 분리한다면 전형적인 전략패턴을 사용하면 된다. 
하지만 전략 패턴으로는 구체적인 구현 코드는 제거했을지 몰라도 위임을 통해 기능을 사용하는 코드는 핵심코드와 함께 남아 있다. 

이와 같은 부가 기능 전부를 핵심 코드가 담긴 클래스에서 독립시킬 수 있다.  
부가 기능을 담은 클래스는 중요한 특징이 있는데, **원래 핵심 기능을 가진 클래스로 위임해줘야 한다.**  
즉, 부가기능이 핵심기능을 사용하는 구조가 되어야 한다.  

이렇게 만든 구조를, 클라이언트가 핵심기능을 가진 클래스를 직접 사용하는 것이 아닌 부가기능을 구현한 클래스를 사용하게 하여 핵심기능을 사용하게 만든다. 

이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 **프록시** 라고 부르고,  
프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 **타깃** 이라고 한다. 

프록시의 특징은 1. 타깃과 같은 인터페이스를 구현했다는 것과 2. 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다. 

프록시는 목적에 따라 두 가지로 구분할 수 있다. 
1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해 
2. 타깃에 부가적인 기능을 부여해주기 위해 

프록시를 두고 사용한다는 점은 동일 하지만, 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분한다. 


### 데코레이터 패턴 

데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.  
데코레이터라는 이름은 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있는 것이 제품은 같은데 다른 포장지로 감싸는 것처럼 보이기 때문이다. 
  
특징은 각 데코레이터가 위임하는 대상에도 인터페이스를 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.  
그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.  

이는 스프링의 DI를 이용하면 아주 편리한데, 데코레이터 빈의 프로퍼티로 같은 인터페이스를 구현한 다른 데코레이터 또는 타깃 빈을 설정하면 된다.  

### 프록시 패턴 

####프록시 vs 프록시 패턴 

프록시는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭했다면,  
프록시 패턴은 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가르킨다.  

프록시의 타깃의 기능을 확장하거나 추가하는 것이 아니라, 클라이언트가 타깃에 접근하는 방식을 변경해준다.  

타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 것이 좋다. 
그런데 타깃 오브젝트에 대한 레퍼런스가 피리 필요할 때, 프록시 패턴을 적용하여  실제 타깃 오브젝트를 넘기는 것이 아닌 프록시를 넘겨주는 것이다.  
그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.  


이와 같이 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이 프록시 패턴이다. 


구조적으로 보면 프록시와 데코레이터는 유사하지만, 프록시는 자신이 만들거나 접근할 타깃 클래스의 정보를 알고 있는 경우가 많다.  
 
 

## 다이나믹 프록시 

개발자들은 프록시 만드는 것을 귀찮아 한다. 그래서 자바에서는 쉽게 만들 수 있도록 하는 클래스들을 지원한다. 

### 프록시의 구성과 프록시 작성의 문제점 

1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다. 
2. 부가기능 코드가 중복될 가능성이 많아진다. 

1번을 해결하기 위해 JDK의 다이나믹 프록시가 있다. 


### 리플렉션 

다이나믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.  
**리플렉션**은 자바의코드 자체를 추상화해서 접근하도록 만든 것이다  
 

 ```java
 public class ReflectionTest {
     @Test
     public void invokeMethod() throws Exception {
         String name = "Spring";
 
         // length()
         assertThat(name.length(), is(6));
 
         Method lengthMethod = String.class.getMethod("length");
         assertThat((Integer)lengthMethod.invoke(name), is(6));
 
         // charAt()
         assertThat(name.charAt(0), is('S'));
 
         Method charAtMethod = String.class.getMethod("charAt", int.class);
         assertThat((Character)charAtMethod.invoke(name,0), is('S'));
     }
 }
 
 
 ```
 
 ### 프록시 클래스 
 
 다이나믹 프록시를 이용한 프록시를 만들어보자. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 