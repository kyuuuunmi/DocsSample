
세밀하게 튜닝된 트랜잭션 속성을 적용해야 하는 경우는? 



## 트랜잭션 애노테이션 

### `@Transactional` 
`Transactional`애노테이션의 타깃은 메소드와 타입이다. 따라서 메소드, 클래스, 인터페이스에 사용할 수 있다. 

이 애노테이션을 트랜잭션 속성정보로 사용하도록 지정하면 스프링은 `@Transactional`이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식한다.  

이 때 사용되는 포인트컷은 `TransactionAttrivuteSourcePointcut`인데, 스스로 표현식과 같은 선정기준을 갖고 있진 않다.  
대신 `@Transactional`이 타입 레벨이든 메소드 레벨이든 상관없이 부여된 빈 오브젝트를 모두 찾아서 포인트컷의 선정 결과로 돌려준다.  

> 트랜잭션 속성 정의 + 포인트컷의 자동등록
 
### 트랜잭션 속성을 이용하는 포인트컷
 
 `@Transactional`은 메소드마다 다르게 설정할 수도 있으므로 매우 유연한 트랜잭션 속성 설정이 가능하다. 
 트랜잭션 부가기능 적용 단위는 메소드다. 따라서 메소드마다 부여하고 속성을 지정하여 유연하고 세세한 제어는 가능하겠지만, 코드는 지저분해질 수도 있다.
  
 
### 대체 정책 
그래서 스프링은 `@Transactional`을 적용할 때 4단계의 대체 정책을 이용하게 해준다. 
메소드의 속성을 확인할 때 **타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입**의 순서에 따라서 어노테이션이 적용됐는지 차례로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.  






#### Issue
- 트랜잭션 어노테이션을 적용했을 때, application-context.xml에서 `transactionAdvice`을 지우면 왜 안될까 
 
 
 