`UserDaoTest`의 두 가지 문제점을 개선해보자. 


## 테스트 검증의 자동화 

첫 번째 문제점인 테스트 결과의 검증 부분을 코드로 만들어보자.  
**확인사항** : `add()`에 전달한 `User` 오브젝트에 담긴 사용자 정보와 `get()`을 통해 다시 DB에서 가져온 `User`오브젝트의 정보가 서로 정확히 일치하는가? 

모든 테스트는 성공 실패의 두 가지 결과를 가질 수 있고, 테스트 실패는 테스트가 진행되는 동안의 에러로 실패하거나, 결과가 기대한 것과 달라 실패하는 경우로 나올 수 있다.  
전자는 테스트 에러, 후자는 테스트 실패로 구분하자. 

테스트 결과를 코드에서 직접 확인하고, 기대와 다를 때에는 "실패"라는 메시지를 출력하도록 해보자. 

```java
if(!user.getName().equals(user2.getName())){
    System.out.println("테스트 실패 (name)");
} else if (!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패 (password)");
} else { 
    System.out.println("조회 테스트 성공");
}
```

자동화된 이 테스트는 두 가지 기능이 정상적으로 동작하는지를 언제든지 손쉽게 확인할 수 있게 해준다. 
개발 과정또는 유지보수를 하면서 개발자는 마음의 평안과 자신감 그리고 새로 도입한 기술이 문제 없는지 가장 빠르게 확인할 수 있는 좋은 방법은 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 _자동화된 테스트를 만들어 두는 것_이다. 


## 테스트의 효율적인 수행과 결과 관리 

더 편리한 테스트를 수행하고 결과를 확인하기 위해서는 단순한 `main()`메소드로는 한계가 있다. 
일정한 패턴을 가진 테스트를 만들 수 있고 많은 테스트를 간단히 실행시킬 수 있으며 결과를 종합해서 확인하고 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘 도구와 작성방법이 필요하다.

자바에는 유명한 테스트 지원기구 JUnit이 있다.

### Junit 테스트로의 전환 
Junit은 프레임워크이다. `main()`메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다. 

### 테스트 메소드 전환
새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두가지를 따라야 한다. 
1. 메소드의 `public` 선언 
2. 메소드에 `@Test` 어노테이션 부착 

### 검증 코드 전환 

```java
if (!user.getName().equals(user2.getName())) { ... }
```
테스트 결과를 검증하는 if/else 문장을 JUnit에서는 어떻게 나타낼 것인가.  
`assertThat()`이라는 스태틱 메소드를 이용할 수 있다. 

``` java
assertThat(user2.getName(), is(user.getName()));
```

`assertThat()`는 첫 번째 파라미터 값을 뒤에 나오는 matcher라 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다.  
`is()`는 matcher의 일종으로 `equals()`로 비교해주는 기능을 가졌다. 


### JUnit 테스트 실행 
JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다. 어디에서든 main()메소드를 하나 추가하고 그 안에 `JUnitCore`클래스의 main메소드를 호출해주는 간단한 코드를 넣어주면 된다.

테스트가 성공하면 결과를 나타내주고, 실패했다면 왜 실패했는지 실패 메세지가 뜬다. 
`asswertThat()`의 조건을 만족하지 못하면 테스트가 실패했음을 알려주는데, 테스트 수행 중에 일반 예외가 발생한 경우도 테스트 수행은 중단되고 테스트는 실패한다.
 




